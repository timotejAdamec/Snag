# GCP File Storage Setup Plan

## Current State

- The `Structure` model already has a `floorPlanUrl: String?` field stored in the database
- The frontend uses **Coil3** to load images from URLs (`AsyncImage`, `CoilZoomAsyncImage`)
- There is **no file upload infrastructure** — no multipart handling, no storage backend
- The backend uses Ktor 3.4.0 + Exposed ORM + SQLite + Koin DI

The goal: allow the frontend to upload images (floor plans, potentially finding photos in the future), store them in GCP Cloud Storage, and serve them back via URL.

---

## Part 1: GCP Infrastructure Setup

### 1.1 Create a GCP Project (if not done)

```bash
gcloud projects create snag-app --name="Snag"
gcloud config set project snag-app
gcloud billing accounts list  # link billing
```

### 1.2 Enable Cloud Storage API

```bash
gcloud services enable storage.googleapis.com
```

### 1.3 Create a Storage Bucket

```bash
# Choose a region close to your server
gsutil mb -l europe-west1 -c STANDARD gs://snag-app-files

# Set uniform bucket-level access (recommended)
gsutil uniformbucketlevelaccess set on gs://snag-app-files
```

**Naming convention for objects inside the bucket:**
```
structures/{structureId}/floor-plan/{filename}
findings/{findingId}/photos/{filename}
```

### 1.4 Configure Access

Two options depending on your deployment model:

#### Option A: Service Account Key (simplest for dev / VM deployment)

```bash
# Create a service account
gcloud iam service-accounts create snag-storage \
    --display-name="Snag Storage Service Account"

# Grant it Storage Object Admin on the bucket
gsutil iam ch serviceAccount:snag-storage@snag-app.iam.gserviceaccount.com:objectAdmin gs://snag-app-files

# Download a key file (keep this secret)
gcloud iam service-accounts keys create gcp-credentials.json \
    --iam-account=snag-storage@snag-app.iam.gserviceaccount.com
```

Set the environment variable on your server:
```bash
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/gcp-credentials.json
```

#### Option B: Workload Identity (for Cloud Run / GKE)

If deploying to Cloud Run or GKE, use Workload Identity Federation instead of key files — no credentials to manage. The default service account (or an attached one) gets automatic access.

### 1.5 Public vs Signed URL Access

**Two strategies for serving images to the frontend:**

| Strategy | Pros | Cons |
|----------|------|------|
| **Public bucket** | Simple — store URL, Coil loads directly | No access control, anyone with URL can access |
| **Signed URLs** | Time-limited access, secure | Backend must generate URLs on every request |

**Recommendation:** Start with **signed URLs** generated by the backend. The upload flow returns a stored object path, and when the frontend needs the image, it requests a signed URL from the backend (or the backend includes it when serving the entity). This keeps the bucket private while still letting Coil load images directly from GCS.

---

## Part 2: Backend Integration (Kotlin / Ktor)

### 2.1 Add Dependencies

In your version catalog (`gradle/libs.versions.toml`):

```toml
[versions]
gcp-storage = "2.49.0"  # check latest

[libraries]
gcp-storage = { module = "com.google.cloud:google-cloud-storage", version.ref = "gcp-storage" }
```

The GCP Storage client is a JVM-only dependency, so it only needs to be added to backend modules.

### 2.2 Architecture — Where Things Go

Following the existing hexagonal pattern:

```
lib/
└── storage/
    └── be/
        ├── api/          # FileStorage port interface
        │   └── build.gradle.kts  (snagBackendModule)
        │   └── src/main/kotlin/.../
        │       └── FileStorage.kt
        └── impl/         # GCP implementation
            └── build.gradle.kts  (snagDrivenBackendModule)
            └── src/main/kotlin/.../
                ├── GcpFileStorage.kt
                └── StorageModule.kt   # Koin module
```

This makes `FileStorage` a **reusable port** that any feature can depend on (structures for floor plans, findings for photos, etc.).

### 2.3 Define the Port Interface

```kotlin
// lib/storage/be/api/.../FileStorage.kt

interface FileStorage {
    /**
     * Upload a file. Returns the stored object path (not a full URL).
     * Example path: "structures/abc-123/floor-plan/image.jpg"
     */
    suspend fun upload(
        path: String,
        content: ByteArray,
        contentType: String,
    ): String

    /**
     * Generate a time-limited signed URL for reading.
     */
    suspend fun getSignedUrl(path: String, expirationMinutes: Long = 60): String

    /**
     * Delete a file by its stored path.
     */
    suspend fun delete(path: String)
}
```

### 2.4 Implement GCP Cloud Storage Adapter

```kotlin
// lib/storage/be/impl/.../GcpFileStorage.kt

internal class GcpFileStorage(
    private val bucketName: String,
) : FileStorage {

    private val storage: Storage = StorageOptions.getDefaultInstance().service

    override suspend fun upload(
        path: String,
        content: ByteArray,
        contentType: String,
    ): String = withContext(Dispatchers.IO) {
        val blobId = BlobId.of(bucketName, path)
        val blobInfo = BlobInfo.newBuilder(blobId)
            .setContentType(contentType)
            .build()
        storage.create(blobInfo, content)
        path
    }

    override suspend fun getSignedUrl(
        path: String,
        expirationMinutes: Long,
    ): String = withContext(Dispatchers.IO) {
        val blobInfo = BlobInfo.newBuilder(BlobId.of(bucketName, path)).build()
        storage.signUrl(
            blobInfo,
            expirationMinutes,
            TimeUnit.MINUTES,
            Storage.SignUrlOption.withV4Signature(),
        ).toString()
    }

    override suspend fun delete(path: String) = withContext(Dispatchers.IO) {
        storage.delete(BlobId.of(bucketName, path))
        Unit
    }
}
```

### 2.5 Koin Module

```kotlin
// lib/storage/be/impl/.../StorageModule.kt

val storageModule = module {
    single<FileStorage> {
        GcpFileStorage(
            bucketName = System.getenv("GCS_BUCKET_NAME") ?: "snag-app-files",
        )
    }
}
```

Register in `BackendModulesAggregate`:
```kotlin
val backendModulesAggregate = listOf(
    // ... existing modules
    storageModule,
)
```

### 2.6 Add File Upload Route

Add a file upload endpoint in the structures feature (or create a shared files route):

```kotlin
// feat/structures/be/driving/impl/.../StructureFilesRoute.kt

internal class StructureFilesRoute(
    private val uploadFloorPlanUseCase: UploadFloorPlanUseCase,
    private val getFloorPlanUrlUseCase: GetFloorPlanUrlUseCase,
) : AppRoute {

    override fun Route.setup() {
        route("/structures/{structureId}/floor-plan") {

            put {
                val structureId = getIdFromParameters("structureId")
                val multipart = call.receiveMultipart()
                var filePath: String? = null

                multipart.forEachPart { part ->
                    if (part is PartData.FileItem) {
                        val contentType = part.contentType?.toString() ?: "application/octet-stream"
                        val bytes = part.provider().readRemaining().readByteArray()
                        filePath = uploadFloorPlanUseCase(structureId, bytes, contentType)
                    }
                    part.dispose()
                }

                filePath?.let {
                    call.respond(HttpStatusCode.OK, mapOf("path" to it))
                } ?: call.respond(HttpStatusCode.BadRequest)
            }

            get {
                val structureId = getIdFromParameters("structureId")
                val signedUrl = getFloorPlanUrlUseCase(structureId)
                signedUrl?.let {
                    call.respond(HttpStatusCode.OK, mapOf("url" to it))
                } ?: call.respond(HttpStatusCode.NotFound)
            }
        }
    }
}
```

### 2.7 Use Cases

```kotlin
// UploadFloorPlanUseCase
interface UploadFloorPlanUseCase {
    suspend operator fun invoke(
        structureId: Uuid,
        content: ByteArray,
        contentType: String,
    ): String
}

// Implementation
internal class UploadFloorPlanUseCaseImpl(
    private val fileStorage: FileStorage,
    private val structuresDb: StructuresDb,
) : UploadFloorPlanUseCase {

    override suspend fun invoke(
        structureId: Uuid,
        content: ByteArray,
        contentType: String,
    ): String {
        val extension = contentType.substringAfter("/")  // e.g. "jpeg", "png"
        val path = "structures/$structureId/floor-plan/image.$extension"

        fileStorage.upload(path, content, contentType)

        // Update structure's floorPlanUrl with the storage path
        structuresDb.updateFloorPlanUrl(structureId, path)

        return path
    }
}
```

### 2.8 Ktor Multipart Configuration

No special plugin install needed — Ktor supports `receiveMultipart()` out of the box. You may want to configure request size limits in the server setup:

```kotlin
// In a new AppConfiguration or in Application.main()
install(RequestValidation) {
    // optional: validate content types, etc.
}

// Set max upload size (e.g. 20 MB)
// In application.conf or programmatically:
install(io.ktor.server.plugins.dataconversion.DataConversion)
```

Or, programmatically in the embedded server config:
```kotlin
embeddedServer(Netty, configure = {
    maxContentLength = 20 * 1024 * 1024  // 20 MB
}) { ... }
```

---

## Part 3: Frontend Integration

### 3.1 Upload Flow

The frontend already uses `HttpClient` from Ktor. Add a multipart upload function:

```kotlin
suspend fun uploadFloorPlan(structureId: Uuid, imageBytes: ByteArray, contentType: String): String {
    val response = httpClient.put("/structures/$structureId/floor-plan") {
        setBody(
            MultiPartFormDataContent(
                formData {
                    append("file", imageBytes, Headers.build {
                        append(HttpHeaders.ContentType, contentType)
                        append(HttpHeaders.ContentDisposition, "filename=floor-plan.jpg")
                    })
                }
            )
        )
    }
    return response.body<Map<String, String>>()["path"]!!
}
```

### 3.2 Image Display

The frontend already uses Coil3 with `AsyncImage`. Two approaches:

**A) Backend-provided signed URLs (recommended):**
When fetching a Structure, the backend resolves the GCS path to a signed URL before returning the DTO:

```kotlin
// In the structures GET route or a mapper
val dto = structure.toApiDto().copy(
    floorPlanUrl = structure.floorPlanUrl?.let {
        fileStorage.getSignedUrl(it)
    }
)
```

The frontend continues using `AsyncImage(model = structure.floorPlanUrl)` — no changes needed.

**B) Dedicated endpoint:**
Frontend calls `GET /structures/{id}/floor-plan` to get a signed URL, then passes it to Coil.

---

## Part 4: Testing

### 4.1 Fake FileStorage for Tests

```kotlin
// lib/storage/be/test/.../FakeFileStorage.kt

class FakeFileStorage : FileStorage {
    private val files = mutableMapOf<String, ByteArray>()

    override suspend fun upload(path: String, content: ByteArray, contentType: String): String {
        files[path] = content
        return path
    }

    override suspend fun getSignedUrl(path: String, expirationMinutes: Long): String {
        return "https://fake-storage.example.com/$path?signed=true"
    }

    override suspend fun delete(path: String) {
        files.remove(path)
    }

    fun getFile(path: String): ByteArray? = files[path]
}
```

Bind in tests:
```kotlin
override fun additionalKoinModules() = listOf(
    module {
        singleOf(::FakeFileStorage) bind FileStorage::class
    }
)
```

---

## Part 5: Configuration & Security Checklist

- [ ] **Never commit** `gcp-credentials.json` — add to `.gitignore`
- [ ] Set `GCS_BUCKET_NAME` and `GOOGLE_APPLICATION_CREDENTIALS` as environment variables
- [ ] Configure **CORS** to allow multipart uploads from your frontend origins
- [ ] Set a **max upload size** on the Ktor server (e.g. 20 MB)
- [ ] Validate **content types** server-side (only accept `image/jpeg`, `image/png`, etc.)
- [ ] Use **signed URLs with short expiration** (15–60 minutes)
- [ ] Consider **Cloud CDN** in front of the bucket for production performance
- [ ] Set up **lifecycle rules** on the bucket to auto-delete orphaned files

---

## Summary of New Modules/Files

```
lib/storage/
└── be/
    ├── api/                   # FileStorage interface (port)
    └── impl/                  # GcpFileStorage (GCP adapter)

feat/structures/
└── be/
    ├── app/
    │   ├── api/               # + UploadFloorPlanUseCase, GetFloorPlanUrlUseCase
    │   └── impl/              # + implementations
    └── driving/
        └── impl/              # + StructureFilesRoute (multipart upload endpoint)
```

**Gradle dependencies to add:**
- `com.google.cloud:google-cloud-storage` → only in `lib/storage/be/impl`

**Environment variables:**
- `GCS_BUCKET_NAME` — bucket name (default: `snag-app-files`)
- `GOOGLE_APPLICATION_CREDENTIALS` — path to service account JSON key
